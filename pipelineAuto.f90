!****************************************************************************

! homoclinic orbit continuation

! the code reads in fort.10 (parameters) and fort.12 (solution) produced by
! the shooting code shoot4d.f

!     April 2013 (Gert van der Heijden)

!****************************************************************************
!
      SUBROUTINE FUNC(NDIM,U,ICP,PAR,IJAC,F,DFDU,DFDP) 
!     ---------- ---- 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER, INTENT(IN) :: NDIM, ICP(*), IJAC
      DOUBLE PRECISION, INTENT(IN) :: U(NDIM), PAR(*)
      DOUBLE PRECISION, INTENT(OUT) :: F(NDIM)
      DOUBLE PRECISION, INTENT(INOUT) :: DFDU(NDIM,NDIM), DFDP(NDIM,*)
      common /pars/EI,P,aa,bb,u_r

!  parameters:

      EI=PAR(1)
      P=PAR(2)
      aa=PAR(3)
      bb=PAR(4)
      u_r=PAR(5)
      xl=PAR(20)

      f(1)= u(2)

      f(2)= u(3)

      f(3)= u(4)

      f(4)= -1/EI*(P*U(3) + aa*(datan(1d0)/u_r)*u(1) -&
         bb*(datan(1d0)/u_r)**3*u(1)**3 +&
         aa/120*(datan(1d0)/u_r)**5*u(1)**5)

       DO I=1,NDIM
          F(I)=PAR(20)*F(I)
       ENDDO

      END SUBROUTINE FUNC

  
      SUBROUTINE STPNT(NDIM,U,PAR,T)
!     ---------- ----- 

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER, INTENT(IN) :: NDIM
      DOUBLE PRECISION, INTENT(INOUT) :: U(NDIM),PAR(*)
      DOUBLE PRECISION, INTENT(IN) :: T
      dimension FP(NDIM),UI(NDIM,2000),TI(2000)
!
!  constants:
!
!  Initialise the problem parameters from the file 'fort.10':
!
       READ(10,*) EI,P,aa,bb,u_r
       READ(10,*) fp(1),fp(2),fp(3),fp(4)
       READ(10,*) xl,delta
       close(10)
!
!  Read in starting solution from fort.18:
!
         NPOINT=1
5        CONTINUE
            READ(18,*,END=7) TI(NPOINT),(UI(I,NPOINT),I=1,NDIM)
!            write(30,*) ti(npoint),ui(1,npoint),ui(2,npoint),&
!            ui(3,npoint),ui(4,npoint)
            NPOINT=NPOINT+1
         GOTO 5
!
7        CONTINUE
         NPOINT=NPOINT-1
         close(18)
!
!  Scale time to the interval [0,1]:
!
         DO 8 I=1,NPOINT
            TI(I)=TI(I)/TI(NPOINT)
8       CONTINUE

!  We initialise using a solution generated by a lookup table.
!
!  First locate the point in the table by using a binary search:
!
         CALL LOCATE(TI,NPOINT,T,K)
!
!  Interpolate by using a linear spline:
!
         IF ((1.LE.K).AND.(K.LT.NPOINT)) THEN
            DO 10 J=1,NDIM
               SLOPE=(UI(J,K+1)-UI(J,K))/(TI(K+1)-TI(K))
               U(J)=UI(J,K)+SLOPE*(T-TI(K))
10          CONTINUE
         ELSE
            DO 20 J=1,NDIM
               IF (K.EQ.0) THEN
                  U(J)=UI(J,1)
               ELSE
                  U(J)=UI(J,NPOINT)
               ENDIF
20          CONTINUE
         ENDIF

!      EI=0.85d0                           
!      P=0.1d0
!      aa=-0.02d0                         
!      bb=0.7d0                        
!      u_r=0.01d0                          
!
      PAR(1)=EI
      PAR(2)=P 
      PAR(3)=aa
      PAR(4)=bb                        
      PAR(5)=u_r

      PAR(20)=xl

! initial guess

! find fixed point

!      call solvefix(fp,par)                          ! use Newton iterations

      par(6)=fp(1)
      par(7)=fp(2)
      par(8)=fp(3)
      par(9)=fp(4)

      END SUBROUTINE STPNT

!--------- ---- 
      SUBROUTINE BCND(NDIM,PAR,ICP,NBC,U0,U1,FB,IJAC,DBC) 

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER, INTENT(IN) :: NDIM, ICP(*), NBC,IJAC
      DOUBLE PRECISION, INTENT(IN) :: PAR(*),U0(NDIM),U1(NDIM)
      DOUBLE PRECISION, INTENT(OUT) :: FB(NBC)
      DOUBLE PRECISION, INTENT(INOUT) :: DBC(NBC,*)
      dimension rr(4),ri(4),fp(4),a(4,4),vr(4,4),BB(4,4)

      EI=PAR(1)
      P=PAR(2)
      aa=PAR(3)
      bb=PAR(4)
      u_r=PAR(5)

! fixed point

      fp1=par(6)
      fp2=par(7)
      fp3=par(8)
      fp4=par(9)

! NOW DEFINE THE BOUNDARY CONDITIONS

      DO I=1,NBC
	  FB(I)=0d0
      ENDDO

      FB(1)= fp1

      FB(2)= fp2

      FB(3)= fp3

      FB(4)= fp4

       fp(1)=fp1
       fp(2)=fp2
       fp(3)=fp3
       fp(4)=fp4
 
! Jacobian matrix

       call xjac(ndim,fp,a,par)

! take the transpose in order to apply projection boundary conditions 
! a la Beyn (1990) (although precise form is not really important)
!
	do 20 i=1,ndim
	   do 10 j=1,ndim
	      bb(i,j)=a(j,i)
10	   continue
20	continue

! eigenvalues and vectors

       call eigs(bb,rr,ri,vr)

!        check_re1=a(1,1)*vr(1,3)+a(2,1)*vr(2,3)+a(3,1)*vr(3,3)&
!             +a(4,1)*vr(4,3)&
!             -rr(3)*vr(1,3)+ri(3)*vr(1,4)
!        check_im1=a(1,1)*vr(1,4)+a(2,1)*vr(2,4)+a(3,1)*vr(3,4)&
!             +a(4,1)*vr(4,4)&
!             -rr(3)*vr(1,4)-ri(3)*vr(1,3)
!        check_re2=a(1,1)*vr(1,4)+a(2,1)*vr(2,4)+a(3,1)*vr(3,4)&
!             +a(4,1)*vr(4,4)&
!             -rr(4)*vr(1,4)+ri(4)*vr(1,3)
!        check_im2=a(1,1)*vr(1,3)+a(2,1)*vr(2,3)+a(3,1)*vr(3,3)&
!             +a(4,1)*vr(4,3)&
!             -rr(4)*vr(1,3)-ri(4)*vr(1,4)
!
!        write(22,*) check_re1,check_im1,check_re2,check_im2

! project onto unstable manifold:

       FB(5)=vr(1,1)*(u0(1)-fp1)+vr(2,1)*(u0(2)-fp2)+&  ! Ls(x(0)-fix_Point)=0
             vr(3,1)*(u0(3)-fp3)+vr(4,1)*(u0(4)-fp4)
       FB(6)=vr(1,2)*(u0(1)-fp1)+vr(2,2)*(u0(2)-fp2)+&
            vr(3,2)*(u0(3)-fp3)+vr(4,2)*(u0(4)-fp4)

!      FB(5)=vr(1,1)*(u0(1)-fp1)+vr(1,2)*(u0(2)-fp2)+&  ! Ls(x(0)-fix_Point)=0
!             vr(1,3)*(u0(3)-fp3)+vr(1,4)*(u0(4)-fp4)
!       FB(6)=vr(2,1)*(u0(1)-fp1)+vr(2,2)*(u0(2)-fp2)+&
!             vr(2,3)*(u0(3)-fp3)+vr(2,4)*(u0(4)-fp4)

! symmetric section:

       FB(7)=dsin(u1(2))                                        ! sita=Psita=0
       FB(8)=u1(3)

!       DO i=1,NBC
!          write(9,*)I,FB(I)
!       ENDDO

! -- 2 additional conditions in order to free parameters containing
!    the end displacements
!
!  end shortening D:
!
!       SHORT=PAR(20)-u1(5)
!       FB(9)=PAR(10)-SHORT
!
!  (relative) end rotation (R - R_0)/twopi (R_0 is the 'total twist', 
!  subtracted in order to get the clean 'buckling contribution'; note 
!  that the result is given in the range [0,0.5]):
!
!        TWOPI=8D0*DATAN(1D0)
!        IF (U1(6).LT.-1D0) U1(7)=-1D0
!        IF (U1(6).GT.1D0) U1(7)=1D0
!        XNORM=DSQRT(U1(6)**2+U1(7)**2)
!        U1_6=U1(6)/XNORM
!        U1_7=U1(7)/XNORM
!        IF (U1_7.GT.0D0) THEN
!           ROT=DACOS(U1_6)
!           NSIGN=1
!        ELSE
!           ROT=TWOPI-DACOS(U1_6)
!           NSIGN=-1
!        ENDIF
!        ROTATE=ROT-DINT(ROT)
!        IF (ROTATE.LT.0D0) ROTATE=ROTATE+1
!        FB(11)=PAR(11)-ROTATE

      END SUBROUTINE BCND

      SUBROUTINE ICND 
      END SUBROUTINE ICND

      SUBROUTINE FOPT 
      END SUBROUTINE FOPT

      SUBROUTINE PVLS
      END SUBROUTINE PVLS


!****************************************************************************
! Subroutine for finding the fix point
!****************************************************************************
      subroutine solvefix(x,par)
      implicit real*8 (a-h,o-z)
!
      parameter (nx=4)
      parameter (lnx=(nx*(nx+1))/2)
      dimension diag(nx),fjac(nx,nx),r(lnx),qtf(nx)
      dimension wa1(nx),wa2(nx),wa3(nx),wa4(nx)
      dimension x(nx),fv(nx),par(20)
      common /pars/EI,P,aa,bb,u_r
      external fcnn

      EI=PAR(1)
      P=PAR(2)
      aa=PAR(3)
      bb=PAR(4)
      u_r=PAR(5)

      xtol=1d-10                                                   ! tolerance
      maxfev=200                                ! maximum number of iterations
      ml=nx-1
      mu=nx-1
      epsfcn=1d-12
      mode=1
      factor=100d0
      nprint=0
      ldfjac=nx

      call hybrd(fcnn,nx,x,fv,xtol,maxfev,ml,mu,epsfcn,diag,&
                mode,factor,nprint,info,nfev,fjac,ldfjac,r,lnx,&
                qtf,wa1,wa2,wa3,wa4)
 !      if (info.eq.1) then                                      ! convergence
 !        write(6,'(/"iterations converged")')
 !        write(6,'("u1: ",f16.12,"   u2:",f16.12,"   u3: ",f16.12,&
 !        "   u4:",f16.12)') (x(j),j=1,nx)
 !     else
 !        write(6,'(/" no convergence -- error:",i3/)') info
 !     endif
    
      end
!
!*****************************************************************************
! Set up the residual equations (to be zeroed in the Newton iterations)
!*****************************************************************************
      subroutine fcnn(nx,x,fv,iflag)
      implicit real*8 (a-h,o-z)
      dimension fv(nx),x(nx)
      common /pars/EI,P,aa,bb,u_r
!
      U1=x(1)
      U2=x(2)
      U3=x(3)
      U4=x(4)
!
      eq1= U3
!
      eq2= (U4-dcos(U1))/dsin(U1)/dsin(U1)-&
             aa*(1d0+P*dcos(U1))*&
           dsin(U1)*dcos(U2)/dsqrt(u_r-2d0*aa*U4)&
           -P*aa/bb*dsin(U1)*dcos(U2)*&
            dsin(U1)*dcos(U2)&
           -EI
!
      eq3= -(U4-dcos(U1))*(1d0-U4*dcos(U1))/dsin(U1)&
              /dsin(U1)/dsin(U1)&
           +bb*dsin(U1)*(1d0+P*dcos(U1))&
             -(dcos(U1)+P*(dcos(U1)*dcos(U1)&
              -dsin(U1)*dsin(U1)))*&
            dcos(U2)*dsqrt(u_r-2d0*aa*U4)&
            -P/bb*dsin(U1)*dcos(U1)*dcos(U2)*&
            dcos(U2)*(u_r-2d0*aa*U4)
!
      eq4= (1d0+P*dcos(U1))*dsin(U1)*dsin(U2)*&
              dsqrt(u_r-2d0*aa*U4)+&
             P/bb*dsin(U2)*(u_r-2d0*aa*U4)*&
              dsin(U1)*dsin(U1)*dcos(U2)
!
      fv(1)=eq1
      fv(2)=eq2
      fv(3)=eq3
      fv(4)=eq4

!     print*, 'test3',fv(1),fv(2),fv(3),fv(4),U2
!
!13   format(4e15.6,"   ",4e15.6)
!     write(*,*)' '
      return
      end

!**********************************************************************
! Subroutine for evaluating the vector field
!****************************************************************************
      subroutine xjac(n,u,a,par)
      implicit real*8 (a-h,o-z)
      dimension u(n),a(n,n),par(20)
      common /init/xl,delta

        EI=PAR(1)
        P=PAR(2)
        aa=PAR(3)
        bb=PAR(4)
        u_r=PAR(5)

        a(1,1) = 0
        a(1,2) = 1
        a(1,3) = 0
        a(1,4) = 0
        a(2,1) = 0
        a(2,2) = 0
        a(2,3) = 1
        a(2,4) = 0
        a(3,1) = 0
        a(3,2) = 0
        a(3,3) = 0
        a(3,4) = 1
        a(4,1) = -1/EI*(aa*(datan(1d0)/u_r) - 3*bb*(datan(1d0)/u_r)**3*&
                 u(1)**2 + 5*aa/120*(datan(1d0)/u_r)**5*u(1)**4)
        a(4,2) = 0
        a(4,3) = -1/EI * P

!	write(11,*) 'corresponding jacobe matrix: '
!	write(11,*) 'par(4)',par(4)
!	write(11,*) a(1,1),a(1,2),a(1,3),a(1,4)
!	write(11,*) a(2,1),a(2,2),a(2,3),a(2,4)
!	write(11,*) a(3,1),a(3,2),a(3,3),a(3,4)
!	write(11,*) a(4,1),a(4,2),a(4,3),a(4,4)

      return
      end
!
!       ---------------------------
        subroutine eigs(a,rr,ri,vr)
!       ---------------------------
!
!       -calculates eigenvectors spanning the unstable manifold 
!        (using the NAG routine F02AGF).
!
	implicit double precision (a-h,o-z)
	parameter(ia=4,n=4,ivr=4,ivi=4,iou=4,zero=1d-7)
        dimension a(4,4),rr(4),ri(4),vi(4,4),vr(4,4),v(2,4)
        dimension rrdum(4),ridum(4),vrdum(4,4),vidum(4,4)
	dimension intger(4)
        common /pars/EI,P,aa,bb,u_r
!
        ifail=0
!
	call f02agf(a,ia,n,rr,ri,vr,ivr,vi,ivi,intger,ifail)
!
        if (ifail.ne.0) then   
           print*,'failed  !!!'
           print*,'ifail=',ifail
        endif
!	print*,'number of iterations for each eigenvalue:'
!	print 10,intger(1),intger(2),intger(3),intger(4)
10	format(2x,i10,2x,i10,2x,i10,2x,i10,2x,i10,2x,i10)
!
!  ORDER THE EIGENVECTORS/VALUES ACCORDING SIZE OF REAL PART OF EIGENVALUE.
!
        do 200 i=1,3
           do 100 j=i+1,4
              if (rr(i).gt.rr(j)) then
                 rrdum(i)=rr(i)
                 ridum(i)=ri(i)
                 rr(i)=rr(j)
                 ri(i)=ri(j)
                 rr(j)=rrdum(i)
                 ri(j)=ridum(i)
                 do 70 k=1,4
                    vrdum(k,i)=vr(k,i)
                    vidum(k,i)=vi(k,i)
                    vr(k,i)=vr(k,j)
                    vi(k,i)=vi(k,j)
                    vr(k,j)=vrdum(k,i)
                    vi(k,j)=vidum(k,i)
70               continue
              endif
100        continue
200     continue
!
!  USE REAL AND IMAGINARY PARTS OF COMPLEX EIGENVECTORS.
!
        do 300 i=1,3
           if (dabs(vr(1,i)-vr(1,i+1)).lt.zero) then
              if (dabs(vr(2,i)-vr(2,i+1)).lt.zero) then
                 if (dabs(vr(3,i)-vr(3,i+1)).lt.zero) then
                    if (dabs(vr(4,i)-vr(4,i+1)).lt.zero) then
                             do 250 j=1,4
                                vr(j,i+1)=vi(j,i)
250                          continue
                          endif
                       endif
                    endif
                 endif
300     continue

!        check_re1=a(1,1)*vr(3,1)+a(1,2)*vr(3,2)+a(1,3)*vr(3,3)&
!             +a(1,4)*vr(3,4)&
!             -rr(3)*vr(3,1)+ri(3)*vr(4,1)
!        check_im1=a(1,1)*vr(4,1)+a(1,2)*vr(4,2)+a(1,3)*vr(4,3)&
!             +a(1,4)*vr(4,4)&
!             -rr(3)*vr(4,1)-ri(3)*vr(3,1)
!        check_re2=a(1,1)*vr(4,1)+a(1,2)*vr(4,2)+a(1,3)*vr(4,3)&
!             +a(1,4)*vr(4,4)&
!             -rr(4)*vr(4,1)+ri(4)*vr(3,1)
!        check_im2=a(1,1)*vr(3,1)+a(1,2)*vr(3,2)+a(1,3)*vr(3,3)&
!             +a(1,4)*vr(3,4)&
!             -rr(4)*vr(3,1)-ri(4)*vr(4,1)

!	write(iou,*) 'par(4)'
!	write(iou,*)  bb
!	write(iou,*) '(ordered) eigenvalues: '
!	write(iou,*) '   (',rr(1),ri(1),')'
!	write(iou,*) '   (',rr(2),ri(2),')'
!	write(iou,*) '   (',rr(3),ri(3),')'
!	write(iou,*) '   (',rr(4),ri(4),')'
!	write(iou,*) 'corresponding eigenvectors: '
!	write(iou,500) vr(1,1),vr(2,1),vr(3,1),vr(4,1)
!	write(iou,500) vr(1,2),vr(2,2),vr(3,2),vr(4,2)
!	write(iou,500) vr(1,3),vr(2,3),vr(3,3),vr(4,3)
!	write(iou,500) vr(1,4),vr(2,4),vr(3,4),vr(4,4)
!
!  LET v CONTAIN THE TWO APPROPRIATE 4D EIGENVECTORS.
!
	do 350 i=1,2
	   do 330 j=1,4
	      v(i,j)=0.0
330	   continue
350	continue
	do 400 i=1,4
	   do 390 j=1,2
	      v(j,i)=vr(i,j+2)
390	   continue
400	continue

        return
!
500	format(2x,'(',f16.12,',',1x,f16.12,',',1x,f16.12,',',1x,&
        f16.12,')')
!
        end
!
!
! Locates the position in the lookup table.
! Ref. Numerical Recipes section 3.4.
!
      SUBROUTINE LOCATE(TI,NPOINT,T,K)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION TI(2000)
!
      JL=0
      JU=NPOINT+1
10    CONTINUE
      IF (JU-JL.GT.1) THEN
         JM=(JU+JL)/2
         IF ((TI(NPOINT).GT.TI(1)).EQV.(T.GT.TI(JM))) THEN
            JL=JM
         ELSE
            JU=JM
         ENDIF
         GOTO 10
      ENDIF
      K=JL
      RETURN
      END
